[General] #dynamic scenarios
sim-time-limit = 100s
description = "General configuration"

**.displayGateSchedules = false
**.gateFilter = "**.eth[1].**"
**.gateScheduleVisualizer.height = 16
**.gateScheduleVisualizer.placementHint = "top"

*.histogramContainer.histograms = {Uplink: "../../../deterministic6g_data/PD-Wireless-5G-1/s1-UL_wall.xml", Downlink: "../../../deterministic6g_data/PD-Wireless-5G-1/s10-DL_wall.xml", 
									Test0: "../../../deterministic6g_data/PD-Wireless-5G-1/test.xml"}


#*.scenarioManager.script = xmldoc(${scenario = "../../scripts/output.xml", "../../scripts/output2.xml"})

*.streamScenarioManager.script = xmldoc(${scenario =  "app-shutdown.xml"})
*.distributionScenarioManager.script = xmldoc("distr-changes.xml")

[Baseline_uplink]
extends = General
network = Dynamicscenario
description = "Basic configuration for networks UPLINK"

*.detCom.dstt[0].delayUplink = rngProvider("histogramContainer","Uplink")

# client applications
*.wirelessdevice1.numApps = 1
*.wirelessdevice1.app[0].typename = "UdpSourceApp"
*.wirelessdevice1.app[*].source.typename = "DynamicPacketSource"

*.wirelessdevice1.app[0].io.destAddress = "device1"
*.wirelessdevice1.app[0].io.destPort = 1001
*.wirelessdevice1.app[0].source.packetLength = 1000B - 54B # 54B = 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.wirelessdevice1.app[0].source.productionInterval = 10ms

# enable outgoing streams
*.wirelessdevice1.hasOutgoingStreams = true

# server applications
*.device1.numApps = 1
*.device1.app[0].typename = "UdpSinkApp"
*.device1.app[0].io.localPort = 1001

*.device2.numApps = 1
*.device2.app[0].typename = "UdpSinkApp"
*.device2.app[0].io.localPort = 1002


[Baseline_downlink]
extends = General
network = Dynamicscenario
description = "Basic configuration for networks DOWNLINK"


*.detCom.dstt[*].delayDownlink = rngProvider("histogramContainer","Downlink")

# client applications
*.device2.numApps = 2
*.device2.app[*].typename = "UdpSourceApp"
*.device2.app[*].source.typename = "DynamicPacketSource"

*.device2.app[0].display-name = "best effort"
*.device2.app[0].io.destAddress = "wirelessdevice2"
*.device2.app[0].io.destPort = 1005


*.device2.app[0].source.packetLength = 1000B + 58B + 12B # 54B = 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.device2.app[0].source.productionInterval = 10ms

*.device2.app[0].source.enabled = false

*.device2.app[1].display-name = "tsn"
*.device2.app[1].io.destAddress = "wirelessdevice1"
*.device2.app[1].io.destPort = 1006

*.device2.app[1].source.packetLength = 1000B + 58B + 12B # 54B = 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.device2.app[1].source.productionInterval = 10ms


# server applications
*.wirelessdevice2.numApps = 2
*.wirelessdevice2.app[0].typename = "UdpSinkApp"
*.wirelessdevice2.app[0].display-name = "best effort"
*.wirelessdevice2.app[0].io.localPort = 1005

*.wirelessdevice2.app[1].typename = "UdpSinkApp"
*.wirelessdevice2.app[1].display-name = "tsn"
*.wirelessdevice2.app[1].io.localPort = 1007

*.wirelessdevice1.numApps = 2
*.wirelessdevice1.app[0].typename = "UdpSinkApp"
*.wirelessdevice1.app[0].display-name = "tsn"
*.wirelessdevice1.app[0].io.localPort = 1006

*.wirelessdevice1.app[1].typename = "UdpSinkApp"
*.wirelessdevice1.app[1].display-name = "best effort"
*.wirelessdevice1.app[1].io.localPort = 1008

[Baseline_RandomWalk]
extends=Baseline_uplink, Baseline_downlink
description = "Basic configuration for networks with a bidirectional communication and a random walk process"

*.detCom.dstt[0].bridging.delayLayer.delayUplink = randomWalk(5.5ms,normal(0ms,100us))
*.detCom.dstt[1].bridging.delayLayer.delayDownlink = randomWalk(3.5ms,normal(0ms,70us))


[Schedule_Configurator]
extends=Baseline_downlink

# automatic gate scheduling
*.gateScheduleConfigurator.typename = "ExternalGateScheduleConfigurator"
# the globally used gate scheduling period in each PeriodicGate modules
*.gateScheduleConfigurator.gateCycleDuration = 0.1s

# 58B = 8B (UDP) + 20B (IP) + 4B (802.1 Q-TAG) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.gateScheduleConfigurator.configuration =
   [{name: "stream1", pcp: 0, gateIndex: 0, application: "app[0]", source: "device2", destination: "wirelessdevice2", packetLength: 1070B, packetInterval: 10ms, maxLatency: 500us},
    {name: "stream2", pcp: 4, gateIndex: 1, application: "app[1]", source: "device2", destination: "wirelessdevice1", packetLength: 1070B, packetInterval: 10ms, maxLatency: 500us}]

# enable outgoing streams
#*.hasEgressTrafficShaping = true

# enable outgoing streams
*.device2.hasOutgoingStreams = true

# client stream identification
*.device2.bridging.streamIdentifier.identifier.mapping = [{stream: "best effort", packetFilter: expr(udp.destPort == 1005)},
                                                          {stream: "tsn", packetFilter: expr(udp.destPort == 1006)}]

# client stream encoding
*.device2.bridging.streamCoder.encoder.mapping = [{stream: "best effort", pcp: 0},
                                                  {stream: "tsn", pcp: 4}]

######################################################################################

# enable streams
*.bridge*.hasIncomingStreams = true
*.bridge*.hasOutgoingStreams = true

*.bridge*.bridging.streamCoder.decoder.mapping = [{pcp: 0, stream: "best effort"},
                                                  {pcp: 4, stream: "tsn"}]

*.bridge*.bridging.streamCoder.encoder.mapping = [{stream: "best effort", pcp: 0},
                                                  {stream: "tsn", pcp: 4}]

# enable incoming streams
*.wirelessdevice*.hasIncomingStreams = true

# enable egress traffic shaping
*.bridge*.hasEgressTrafficShaping = true

# time-aware traffic shaping with 2 queues
*.bridge*.eth[*].macLayer.queue.numTrafficClasses = 2
*.bridge*.eth[*].macLayer.queue.queue[0].display-name = "best effort"
*.bridge*.eth[*].macLayer.queue.queue[1].display-name = "tsn"

#######################################################################################

# enable streams
*.detCom.dstt[*].hasIncomingStreams = true
*.detCom.dstt[*].hasOutgoingStreams = true

*.detCom.nwtt.hasIncomingStreams = true
*.detCom.nwtt.hasOutgoingStreams = true

*.detCom.dstt[*].bridging.streamCoder.decoder.mapping = [{pcp: 0, stream: "best effort"},
                                                  {pcp: 4, stream: "tsn"}]

*.detCom.dstt[*].bridging.streamCoder.encoder.mapping = [{stream: "best effort", pcp: 0},
                                                  {stream: "tsn", pcp: 4}]


# enable egress traffic shaping
*.detCom.dstt[*].hasEgressTrafficShaping = true

# time-aware traffic shaping with 2 queues
*.detCom.dstt[*].eth[0].macLayer.queue.numTrafficClasses = 3
*.detCom.dstt[*].eth[0].macLayer.queue.queue[0].display-name = "best effort"
*.detCom.dstt[*].eth[0].macLayer.queue.queue[1].display-name = "tsn"
*.detCom.dstt[*].eth[0].macLayer.queue.queue[2].display-name = "video"

#######################################################################################


# gate scheduling visualization
#*.visualizer.gateScheduleVisualizer.displayGateSchedules = true
#*.visualizer.gateScheduleVisualizer.displayDuration = 100us
#*.visualizer.gateScheduleVisualizer.gateFilter = "*.bridge1.eth[2].** or *.bridge2.eth[0].**.transmissionGate[0] or *.bridge2.eth[1].**.transmissionGate[1]"
#*.visualizer.gateScheduleVisualizer.height = 16


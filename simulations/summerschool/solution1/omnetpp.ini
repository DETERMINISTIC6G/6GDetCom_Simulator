[General]
sim-time-limit = 10s
description = "Tutorial 1"
*.babblingTalker.app[0].display-name = "babbling"
*.burstyTalker.app[0].display-name = "bursty"
**.hasOutgoingStreams = true

[Task1_1]
network = d6g.simulations.summerschool.solution1.NetworkTask1
# Task 1.1a)
# This task only takes place in the network_task1.ned file.
# Your warm-up task is to complete the network file with the missing 100Mbps EthernetLink.
# Confirm the correct network setup by starting the simulation.

*.listener.numApps = 3
*.listener.app[*].typename = "UdpSinkApp"
*.listener.app[0].io.localPort = 1042
*.listener.app[1].io.localPort = 1043
*.listener.app[2].io.localPort = 1044

[Task1_1b]
extends = Task1_1
# Task 1.1b)
# As you've realized, no messages are sent in the simulation yet.
# 
# Below you are given a template for the setup of a talker (UdpSourceApp) for a time-triggered stream.
# 1. The destination address can for example be a module name, an IP or MAC address.
# 2. The final packet size should be 100B.
# 		Note: The following headers are added by following modules and will increase the packet defined here.
# 		4B (Q-Tag) + 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
#		Note2: The Q-Tag will only be added in a later exercise, so for the final size may be 96B.
# 3. The cycle time should be 10 milliseconds
# Run the simulation to confirm your messages are sent correctly

*.periodicTalker.numApps = 1
*.periodicTalker.app[0].typename = "UdpSourceApp" 
*.periodicTalker.app[0].display-name = "time-triggered"
*.periodicTalker.app[0].io.destPort = 1042
*.periodicTalker.app[0].io.destAddress = "listener" # <YOUR_TASK>
*.periodicTalker.app[0].source.packetLength = 100B - 58B # <YOUR_TASK>
*.periodicTalker.app[0].source.productionInterval = 10ms # <YOUR_TASK>

[Task1_1c]
extends = Task1_1b
*.burstyTalker.numApps = 1
*.burstyTalker.app[0].io.destPort = 1043
# Task 1.1c)
# We provide you with an implementation of a bursty talker, which we enabled above.
# Your task is to run the simulation until the time limit (10s, use express run)
# and make yourself familiar with the OMNeT++ Analysis tool.
# To this end, open the task1.anf file and explore the charts:
# - 1.1c Sent bytes: Shows the total sent bytes per device
# - 1.1c End-to-end delay: Shows the arrival time on the x axis and the end-to-end delay on the y-axis


[Task1_2a]
extends = Task1_1c
*.babblingTalker.numApps = 1
*.babblingTalker.hasOutgoingStreams = true
*.babblingTalker.app[0].io.destPort = 1044
# Task 1.2a)
# We now additionally enable a babbling idiot which floods the network with unwanted messages.
# Run the simulation again and explore how it affects the end-to-end delay in chart
# - 1.2a End-to-end delay






[Task1_2b]
extends = Task1_2a
**.bridging.directionReverser.reverser.excludeEncapsulationProtocols = ["ieee8021qctag"]
**.hasEgressTrafficShaping = true

# Task 1.2b)
# As discovered in the previous exercise, the babbling talker floods the network
# leading to time-triggered streams missing their deadline.
# Your task is to fix this problem by setting up strict priority queueing.

# We want to have three queues, for time-triggered, bursty and best effort traffic:
**.eth[*].macLayer.queue.numTrafficClasses = 3 # <YOUR TASK>
**.eth[*].macLayer.queue.*[0].display-name = "best-effort" 
**.eth[*].macLayer.queue.*[1].display-name = "bursty" # <YOUR TASK>
**.eth[*].macLayer.queue.*[2].display-name = "time-triggered" # <YOUR TASK>

# To sort packts in the right queue, we first need to map packets to an internal stream name.
# Complete the following template with the help of this page:
# https://inet.omnetpp.org/docs/users-guide/ch-packetfilter.html
**.bridging.streamIdentifier.identifier.mapping = [{stream: "time-triggered", packetFilter: expr(udp.destPort == 1042)},
                                                         {stream: "bursty", packetFilter: expr(udp.destPort == 1043)},
														 {stream: "best-effort", packetFilter: expr(udp.destPort == 1043)}]

# Now, we need to map the streams to a pcp value.
# This mapping helps you to select suitable PCP values:
# TODO
**.bridging.streamCoder.encoder.mapping = [{stream: "time-triggered", pcp: 7},
                                                 {stream: "bursty", pcp: 5},
												 {stream: "best-effort", pcp: 0}]

# Explore 1.2b End-to-end delay in task1.anf

[Task1_3]
extends = Task1_2b

# To further improve our solution from Task 1.2b), you should now set up
# the gates of the time-aware shaper at the bridge.

# Complete this template and make sure to chose your durations and offset values
# such that the gate openings of the time-triggered stream and the other streams does not overlap.
*.bridge.eth[*].macLayer.queue.transmissionGate[2].offset = 9990us
*.bridge.eth[*].macLayer.queue.transmissionGate[2].durations = [10us, 9990us]
*.bridge.eth[*].macLayer.queue.transmissionGate[0..1].offset = 9980us
*.bridge.eth[*].macLayer.queue.transmissionGate[0..1].durations = [9990us, 10us]

# Explore your results in Task1.3 End-to-end delay of task1.anf

# Some tips:
# The durations parameter is an array with alternating durations of gate open and gate closed times.
# The first entry is an "open" entry by default
# 
# The offset parameter allows you to start the cycle at a given offset at the beginning of the simulation
#
# Example:
# durations = [6ms, 4ms]
# 1. At the beginning of the simulation, the gate is open for 6ms.
# 2. At t=6ms, the gate closes and stays closed for 4ms.â€š
# 3. At t=10ms, the gate opens again repeating from step 1.
#
# With an additional offet=8ms this would change to:
# 1. At the beginning of the simulation (t=0ms) the cycle is already advanced by 8ms
#		Thus: The gate is closed and stays closed for another 2ms (until the end of the cycle)
# 2. At t=2ms, the gate is opened and says open for 6ms.
# 3. At t=8ms, the gate closes and stays closed for 4ms.
# 4. At t=12ms, the gate opens again repating from step 2.

# Step-by-step hints:
# - Calculate the transmission delay of your 100B frames on a 100MBit link => open duration
# - The close duration is the cycle time minus your open time
# 
# - Calculate the propagatin delay in the foregoing EthernetLink
# 		The lentgh is 10m and lightspeed in a typical cable is approx 200_000_000 m/s


[General]
sim-time-limit = 30s
seed-set = 918273
description = "Tutorial 2"
network = d6g.simulations.summerschool.solution2.NetworkTask2

**.hasOutgoingStreams = true
*.listener.numApps = 2
*.listener.app[*].typename = "UdpSinkApp"
*.listener.app[0].io.localPort = 1042
*.listener.app[1].io.localPort = 1043

**.streamIdentifier.identifier.mapping = [{stream: "stream1", packetFilter: expr(udp.destPort == 1042)},
                                          {stream: "stream2", packetFilter: expr(udp.destPort == 1043)}]

**.streamCoder.decoder.mapping = [{stream: "stream1", packetFilter: expr(udp.destPort == 1042)},
                                  {stream: "stream2", packetFilter: expr(udp.destPort == 1043)}]

**.streamCoder.encoder.mapping = [{stream: "stream1", pcp: 7},
						          {stream: "stream2", pcp: 6}]

**.eth[*].phyLayer.typename = "EthernetStreamingPhyLayer"

**.numTrafficClasses = 8

[Task2_1]
extends = General
*.talker1.numApps = 1
*.talker1.hasOutgoingStreams = true
*.talker1.app[*].typename = "UdpSourceApp"
*.talker1.app[*].display-name = "stream1"
*.talker1.app[*].io.destAddress = "listener"
*.talker1.app[*].source.packetLength = 100B - 58B # 58B = 4B (Q-Tag) + 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.talker1.app[0].io.destPort = 1042
*.talker1.app[0].source.productionInterval = 10ms

# Task 2.1a)
# This task only takes place in the network_task2.ned file.
# Your task is to change the type of the detCom device to a DetCom node.
# 
# Make yourself familiar with the structure of the DetCom node:
# https://deterministic6g.github.io/6GDetCom_Simulator/doc/neddoc/d6g.devices.DetCom.html
# 
# The listener should be connected to the network side of the simulator.
# All other devices should be connected as wireless devices.

# Task 2.1b)
# Confirm that your network works as intended.
# 1. Run the simulation
# 2. Create an .anf file and generate a graph that shows the end to end delay (meanBitLifetimePerPacket) of each packet.


[Task2_2]
extends = Task2_1

*.talker2.numApps = 1
*.talker2.hasOutgoingStreams = true
*.talker2.app[*].typename = "UdpSourceApp"
*.talker2.app[*].display-name = "stream2"
*.talker2.app[*].io.destAddress = "listener"
*.talker2.app[*].source.packetLength = 100B - 58B # 58B = 4B (Q-Tag) + 8B (UDP) + 20B (IP) + 14B (ETH MAC) + 4B (ETH FCS) + 8B (ETH PHY)
*.talker2.app[0].io.destPort = 1043
*.talker2.app[0].source.productionInterval = 10ms
*.talker2.app[0].source.initialProductionOffset = 2.5ms

# As you saw in the previous task, the end-to-end delay is static.
# Delays within the DetCom node are typically variable.

# Task 2.2a)
# Your task is to setup the uplink delay in the DetCom node.
# - The connection of talker1 should use a given Histogram as a delay source.
# 	Use uplink_given.xml (you can see a plot of it in uplink_given.png, it has a mean delay of 5.6ms)
#	Note: For simplicity, we've cut the histogram to a maximum delay of 10ms
# - The connection of talker2 should experience a normal distribution with the following parameters o=2.5ms, u=100us in the DetCom node
# 
# The following documentation might be helpful:
# - Setting up delays in the DetCom node:
# 	https://deterministic6g.github.io/6GDetCom_Simulator/doc/neddoc/d6g.devices.tsntranslator.TsnTranslator.html
# - Reading Histogram files:
# 	https://deterministic6g.github.io/6GDetCom_Simulator/doc/neddoc/d6g.distribution.histogram.HistogramContainer.html
# 	The NED function to draw delays from the Histogram: quantity rngProvider(string rngProviderModule, string key?) 
# 		(Example usage here: https://deterministic6g.github.io/6GDetCom_Simulator/doc/simulations/edgecloud/doc/index.html )

*.histogramContainer.histograms = {uplink: "../task2/uplink_given.xml"}
*.detCom.dstt[0].delayUplink = rngProvider("histogramContainer", "uplink")
*.detCom.dstt[1].delayUplink = normal(2.5ms, 500us)

# Task 2.2b)
# 1. Run the simulation
# 2. In your .anf file, create two Histogram figures showing the end-to-end delays for both streams
# 3. Make sure the Histograms match your expectations (compare the outcoming Histogram with uplink_given.png and the expected normal distribution)

[Task2_3a]
extends = Task2_2

*.bridge.hasEgressTrafficShaping = true
*.bridge.eth[1].macLayer.queue.transmissionGate[7].offset = 10ms - 16.10us - 5.6ms # cycle time - ethernet delay - mean detCom delay
*.bridge.eth[1].macLayer.queue.transmissionGate[7].durations = [10us, 9990us]
*.bridge.eth[1].macLayer.queue.transmissionGate[6].offset = 10ms + 2.5ms - 16.10us - 2.5ms # cycle time + production offset - ethernet delay - mean detCom delay
*.bridge.eth[1].macLayer.queue.transmissionGate[6].durations = [10us, 9990us]

# You are now given a schedule that works for wired network.
# ---------------------------------------------------------
# For reference, we have a 8.050us packet delay per Ethernet
# link (8us = 100byte/100Mbps, 50ns propagation). Hence,
# talker -> detCom: 	[0us, 		8.050us]
# detCom -> bridge: 	[8.050us, 	16.100us]
# bridge -> listener: 	[16.100us,	24.150us]
# ---------------------------------------------------------
# The schedule is configured to use the mean delays of the
# distributions from Task 2. We want to explore what happens
# if the same techniques are used for wireless TSN.
# Task 3a)
# 1. Execute the simulation
# 2. Explore the resulting end-to-end delays. What do you discover?
# 3. In which scenarios could this phenomenon result in violations of the
#    QoS requirements? This about how to fix this problem.
#
# Hint: Zoom in into the first few cycles of the simulation.
#


[Task2_3b]
extends = Task2_2

**.streamCoder.*.mapping = [{stream: "stream1", pcp: 7},
						    {stream: "stream2", pcp: 7}]

*.bridge.hasEgressTrafficShaping = true
*.bridge.eth[1].macLayer.queue.transmissionGate[7].offset = 4.3839ms
*.bridge.eth[1].macLayer.queue.transmissionGate[7].durations = [10us, 5.59ms, 10us, 4.39ms]

# The approach of Task 3a does not scale, as it would require one egress queue per TSN stream.
# (Note that TSN bridges have a limit of 8 FIFO queues per egress port)
# For this reason, we now want to merge the GCLs of both egress queues into one.
# Task 3b)
# 1. Execute the simulation
# 2. Explore the resulting end-to-end delays. What do you discover?
# 3. Would your fix of Task3a help to fix this problem? Explain why or why not.
# 4. What mechanisms of the previous lecture could be used to mitigate this problem?
#    How would this mechanism affect the QoS guarantees.

[Task2_4]
extends = Task2_2
**.streamCoder.encoder.mapping = [{stream: "stream1", pcp: 7},
						          {stream: "stream2", pcp: 7}]

# 2.4) Bonus Task
#
# Use the following documentation:
# https://deterministic6g.github.io/6GDetCom_Simulator/doc/simulations/packetdelaycorrection/doc/index.html
# 1. Set up PDC for the two streams
# 2. Set up a schedule that takes into account your PDC configuration.
# 3. Confirm everything works as intended using the Analysis tool.

*.detCom.nwtt.hasPdc = true
*.detCom.nwtt.bridging.pdc.mapping = [
    {stream: "stream1", pdc: "10ms"},
    {stream: "stream2", pdc: "10ms"}]

*.bridge.hasEgressTrafficShaping = true
*.bridge.eth[1].macLayer.queue.transmissionGate[7].offset = 20ms - 16.10us - 10ms # cycle time - ethernet delay - pdc
*.bridge.eth[1].macLayer.queue.transmissionGate[7].durations = [10us, 2.49ms, 10us, 7.49ms]
